# 问题描述
一个农夫带着一只狼、一只羊、一颗白菜，身处河南岸，他要把这些东西全部运往河北岸。现在他只有一条小船，船只能容下他和一个物品，另外只有农夫才会撑船。如果农夫在场，则狼不能吃羊，羊不能吃白菜，否则狼会吃羊，羊会吃白菜，但狼不吃白菜。请求出农夫将所有的东西运过河的方案。

# 设计要求
1. 构建农夫过河的状态图。
2. 写一个程序，实现上述过河方案。

# 第一次设计
第一次设计的目标是完成设计要求`(1)`。

第一次设计可分为如下五个部分：

1. 状态图定义
2. 状态总集和表示方法
3. 状态合法性
4. 状态连接的建立
5. 状态图构建

现就这五个部分展开详细叙述。

## 状态图定义
状态图的定义包括该图中顶点的定义和边的定义。

在本次设计中，顶点被认为是农夫、狼、羊、白菜四个物品在渡河结束后的一种确定状态，若两个状态能够通过且仅通过一次渡河进行相互转化，则认为这两个状态对应的顶点间有一条无向的边。

## 状态总集和表示方法
状态图定义中提到的四个物品的确切状态存在明确的取值范围。对于任一物品，其只可能处于两种状态之一：

- 位于河的南岸
- 位于河的北岸

因此可以分别用`0`和`1`表示上述两种状态，这样每一种确定状态，都可以得到四个0~1范围间的整数。

若将这四个整数记为`F、W、G、C`，分别表示`农夫`、`狼`、`羊`、`白菜`的状态，则可以将这四个整数按顺序组合成一个四位二进制数，范围为`0000~1111`，对应十进制的`0~15`。

因此，我们成功在状态集合和数集`{0~15}`间建立的一对一的映射关系，我们就可以使用整数`0~15`去表示所有的`16`种状态，例如`F = 0、W = 1、G = 0、C = 1`状态可以用整数`5`(二进制对应`0101`)表示。

## 状态合法性
设计要求中的规则不允许部分状态的存在，如下列状态：

- `F = 1, W = 0, G = 0, C = 1`

这个由整数`9`表示的状态意为：狼和羊在河南岸，农夫和白菜在河北岸。此时，由于没有农夫的看管，狼就会吃羊，违反了设计要求中的规则。

根据题目的要求，可以写出状态非法的判别式：`W == G && F != G || G == C && F != G`，化简后得到：`F != G && (W == G || G == C)`，那么状态合法的判别式就是：`F == G || W != G && G != C`。

## 状态连接的建立
根据状态图的定义，若两个状态间可以通过一次撑船互相转化，则这两个状态对应的顶点间存在一条无向的边。状态图的两个要素就是顶点集和边集，现在顶点集已经确定，只需确认这些顶点间的边即可。

由于撑船的限制，每次撑船后，都会有如下改变：

- 农夫的位置发生变化
- 至多一样物品的位置发生变化

因此下列两个状态就无法通过一次撑船互相转化：

- `F = 0, W = 0, G = 0, C = 0`
- `F = 0, W = 1, G = 0, C = 0`

通过这两条规律，就可以判断任意两个状态对应的顶点间是否有边连接。

## 状态图构建
状态图使用两个数组进行存储。第一个为一维数组`Info`，存储所有节点的状态值；第二个为二维数组`Adj`，表示该状态图的邻接矩阵。在`Info`中，所有状态值升序排列，并且其下标作为对应节点的编号。

为了方便得到图的节点数量，状态图还有一个参数`NodeNum`，记录了图中节点数量。

构建状态图的方法如下：

1. 遍历十六种状态，将合法状态加入`Info`
2. 遍历`Info`，两两判定是否有连接，构建邻接矩阵`Adj`