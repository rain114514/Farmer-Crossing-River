# 问题描述
一个农夫带着一只狼、一只羊、一颗白菜，身处河南岸，他要把这些东西全部运往河北岸。现在他只有一条小船，船只能容下他和一个物品，另外只有农夫才会撑船。如果农夫在场，则狼不能吃羊，羊不能吃白菜，否则狼会吃羊，羊会吃白菜，但狼不吃白菜。请求出农夫将所有的东西运过河的方案。

# 设计要求
1. 构建农夫过河的状态图。
2. 写一个程序，实现上述过河方案。

# 第一次设计
第一次设计的目标是实现设计要求`(1)`：构建农夫过河的状态图。

第一次设计可分为如下四个部分：

1. 问题抽象
2. 状态编码
3. 状态排除
4. 状态连接
5. 状态图的实现

下面就这五个部分展开叙述。

## 问题抽象
实际上，由于算上农夫也只有四个实体，而且每个实体的状态只有两种：

- 处河南岸
- 处河北岸

所以四个实体的分布状态一共$2^4 = 16$种，而农夫不断撑船渡河就是在这16种状态中来回变化。

## 状态编码
最简单的方法就是对各状态按顺序编码0~15，我们可以设定农夫、狼、羊、白菜的状态分别为F、W、G、C，如果状态参数为1，表示对应实体处在河北岸；如果为0，则处在河南岸。所以F、W、G、C可以组成一个四位二进制数，这四位二进制数正好一一对应了0~15这16个数。

因此只要用每个状态对应的二进制数对应的十进制数作为其编码即可。

## 状态排除
由于问题描述中存在三条有关农夫不在场的规则：

- 狼会吃羊
- 羊会吃白菜
- 狼不吃白菜

但这样判断太过复杂，我们需要对规则进行简化。狼、羊、白菜只要农夫在场就相安无事，否则才会规则生效，因此会发生事故的情况是：农夫不在场且狼羊/羊白菜组合存在至少一个。

注意到两个事故发生有一个相同条件是：羊必须不与农夫在一起。因此可以认为，农夫和羊在一起事，不会发生事故。

羊不和农夫在一起时，只有狼和白菜都不与羊在一起，才不会发生事故，因此判断无事发生的条件可以缩写为一句话：羊与农夫在一起或者羊单独处在农夫的对岸。改写为C语言的表达式就是F == G || W != G && C != G。

根据得到的判别规则，可以排除以下几个状态：

- F = 0, W = 1, G = 1, C = 0
- F = 0, W = 0, G = 1, C = 1
- F = 0, W = 1, G = 1, C = 1
- F = 1, W = 0, G = 0, C = 1
- F = 1, W = 1, G = 0, C = 0
- F = 1, W = 0, G = 0, C = 0

最后状态图中只存在十个状态。

## 状态连接
农夫撑船过河就是在状态间不断改变，但并非每个状态间都可以一步到达。例如下面两个状态：

- F = 0, W = 0, G = 0, C = 0
- F = 0, W = 1, G = 0, C = 0

这两个状态间的差别就是狼在农夫撑两次船的情况下凭空从河南岸移动到了河北岸，这是不可能的。因此最终的状态图并非节点数为10的完全图，有一些连接是无法实现的。

根据问题描述中的规则，只有农夫才能撑船，并且每次农夫最多带一样物品撑船，因此下述状态转移是不可能的：

- 两个状态间，农夫的状态没有改变
- 在农夫状态改变的前提下，有超过一个其他物品的状态发生了改变

这两条规则的判定都很简单，即使是第二条也只需要对状态改变的物品进行计数即可进行判断。

## 状态图的实现
由于本次设计中，状态的数量和内容都已经完全确定，因此可以采用邻接矩阵存储状态图。使用一个大小为10的一维数组存储各状态的内容，一个大小为10 * 10的二维数组表示邻接矩阵。下面先用一个简单的例子展示这两个数组之间的关系：

一维数组：$
\left\{
\begin{matrix}
1 & 2 & 4 & 5
\end{matrix}
\right\}
$

二维数组：$
\left\{
\begin{matrix}
0 & 1 & 0 & 0 \\
1 & 0 & 1 & 1 \\
0 & 1 & 0 & 1 \\
0 & 1 & 1 & 0
\end{matrix}
\right\}
$

这样就表示，这个图存在4个节点，4个节点的数据依次为1、2、4、5，同时节点1与节点2连接，节点2和节点4、节点5连接，节点4和节点5连接。

构建两个矩阵，只需要知道所有节点的元素值以及相互之间的连接关系就可以做到了。在之前的步骤中，我们已经得知了所有的状态以及状态之间的联系，因此构建邻接矩阵其实并不难。